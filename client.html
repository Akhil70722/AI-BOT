<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>AI Voicebot - Chat</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background: radial-gradient(1200px 800px at 10% -10%, #1a2332, #0b0f14);
      color: #e7edf3;
      min-height: 100vh;
    }
    
    .container {
      max-width: 980px;
      margin: 0 auto;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    .header {
      background: linear-gradient(90deg, #0f1622, #0c121a);
      color: #e7edf3;
      padding: 16px 20px;
      text-align: center;
      border-bottom: 1px solid #1d2733;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    
    .header h1 {
      margin: 0;
      font-size: 2em;
    }
    
    .chat-container {
      flex: 1;
      overflow-y: auto;
      padding: 20px 20px 8px;
      background: linear-gradient(180deg, #0b1117, #0a0f14);
      border-bottom: 1px solid #1d2733;
    }
    
    .message {
      margin-bottom: 14px;
      padding: 12px 14px;
      border-radius: 14px;
      max-width: 70%;
      word-wrap: break-word;
      white-space: pre-wrap;
      box-shadow: 0 6px 20px rgba(0,0,0,.25);
      border: 1px solid #1d2733;
    }
    
    .user-message {
      background: #2563eb;
      color: white;
      margin-left: auto;
      text-align: right;
    }
    
    .bot-message {
      background: #0f1722;
      color: #e7edf3;
      margin-right: auto;
    }
    
    .error-message {
      background: #7f1d1d;
      color: #fff;
      margin-right: auto;
      border-color: #a11a1a;
    }
    
    .input-container {
      padding: 12px;
      background: linear-gradient(180deg, #0d141d, #0a0f14);
      border-top: 1px solid #1d2733;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    
    #msg {
      flex: 1;
      padding: 14px 16px;
      border: 1px solid #223041;
      background: #0d1319;
      color: #e7edf3;
      border-radius: 12px;
      font-size: 16px;
      outline: none;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    
    #msg:focus {
      border-color: #2b6cb0;
      box-shadow: 0 0 0 3px rgba(43,108,176,0.25);
    }
    
    button {
      padding: 12px 18px;
      background: linear-gradient(135deg, #7c8aff, #9c6bff);
      color: white;
      border: 1px solid #223041;
      border-radius: 12px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 700;
      transition: transform 0.12s ease-in-out, opacity .2s;
    }
    
    button:hover {
      transform: translateY(-2px);
    }
    
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }
    
    .voice-btn {
      padding: 12px;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }
    
    .voice-btn.recording {
      background: #dc3545;
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    
    .status {
      text-align: center;
      padding: 10px;
      font-size: 14px;
      color: #666;
    }
    
    .connected {
      color: #28a745;
    }
    
    .disconnected {
      color: #dc3545;
    }
    
    .typing {
      font-style: italic;
      color: #666;
    }
    
    .controls {
      padding: 10px 12px;
      background: #0a0f14;
      border-top: 1px solid #1d2733;
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      flex-wrap: wrap;
    }
    
    .controls button {
      padding: 8px 16px;
      font-size: 14px;
      background: #6c757d;
    }
    
    .voice-status {
      font-size: 12px;
      color: #666;
      margin-left: 10px;
    }
    
    .audio-player {
      margin-top: 10px;
      width: 100%;
    }
    
    .transcription {
      font-style: italic;
      color: #666;
      margin-top: 5px;
      font-size: 12px;
    }
    
    .input-info {
      text-align: center;
      padding: 5px;
      font-size: 12px;
      color: #666;
      background: #f8f9fa;
      border-top: 1px solid #dee2e6;
    }
    
    .session-info {
      text-align: center;
      padding: 5px;
      font-size: 10px;
      color: #999;
      background: #f8f9fa;
      border-top: 1px solid #dee2e6;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üé§ AI Voicebot Chat</h1>
      <p>Powered by Gemini AI + Voice Integration</p>
    </div>
    
    <div class="status" id="status">Connecting...</div>
    
    <div class="chat-container" id="chat">
      <div class="message bot-message">
        Hello! I'm your AI assistant with voice capabilities. You can type your message or click the microphone to speak!
      </div>
    </div>
    
    <div class="controls">
      <button type="button" onclick="clearChat()">Clear Chat</button>
      <button type="button" onclick="exportChat()">Export Chat</button>
      <button type="button" onclick="reconnect()">Reconnect</button>
      <button type="button" onclick="downloadAudioLogs()">Download Audio Logs</button>
    </div>
    
    <div class="input-container">
      <input id="msg" placeholder="Type your message here..." onkeypress="handleKeyPress(event)"/>
      <button type="button" onclick="sendMessage()" id="sendBtn">Send</button>
      <button type="button" onclick="startRecording()" id="recordBtn" class="voice-btn">üé§</button>
      <button type="button" onclick="stopRecording()" id="stopBtn" class="voice-btn" style="display: none;">‚èπÔ∏è</button>
      <div class="voice-status" id="voiceStatus"></div>
    </div>
    
    <div class="input-info">
      üí° You can type your message OR click the microphone to speak
    </div>
    
    <div class="session-info" id="sessionInfo">
      Session ID: <span id="sessionId">Connecting...</span>
    </div>
  </div>

  <script>
    let ws = null;
    let isConnected = false;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;
    let audioContext = null;
    let sessionId = null;
    let clientAudioLogs = [];
    let keepAliveInterval = null;
    // Persisted messages stored as array of {role: 'user'|'bot'|'error', text: string}
    let persistedMessages = [];

    // Load chat history from localStorage first, then append backend history if available
    async function loadChatHistory() {
      const chat = document.getElementById("chat");
      // Initial greeting only once
      chat.innerHTML = '<div class="message bot-message">Hello! I\'m your AI assistant with voice capabilities. You can type your message or click the microphone to speak!</div>';

      // Local cache
      try {
        const cached = localStorage.getItem('chatHistoryJson');
        if (cached) {
          persistedMessages = JSON.parse(cached);
          persistedMessages.forEach(m => addMessage(m.text, m.role, false));
        }
      } catch (e) {
        console.warn('Failed to read cached chat history:', e);
      }

      // Backend history (best effort)
      try {
        const res = await fetch('http://127.0.0.1:8081/chat_history', { cache: 'no-store' });
        if (res.ok) {
          const history = await res.json();
          history.forEach(row => {
            if (row.user_message && row.user_message !== 'N/A') {
              addMessage(row.user_message, 'user', true);
            }
            if (row.bot_response && row.bot_response !== 'N/A') {
              addMessage(row.bot_response, 'bot', true);
            }
          });
        }
      } catch (e) {
        console.log('Backend history not available (continuing with cache):', e);
      }

      chat.scrollTop = chat.scrollHeight;
    }

    // Save chat history to localStorage as JSON array for reliability
    function saveChatHistory() {
      try {
        localStorage.setItem('chatHistoryJson', JSON.stringify(persistedMessages));
      } catch (e) {
        console.warn('Failed to persist chat history:', e);
      }
    }
    
    function connect() {
      try {
        ws = new WebSocket("ws://127.0.0.1:8765");
        
        ws.onopen = function() {
          isConnected = true;
          reconnectAttempts = 0;
          updateStatus("Connected", "connected");
          document.getElementById("sendBtn").disabled = false;
          console.log("WebSocket connected successfully");
        };
        
        ws.onmessage = function(event) {
          removeTypingIndicator();
          
          console.log("Raw message received:", event.data);
          
          try {
            const data = JSON.parse(event.data);
            console.log("Parsed data:", data);
            
            if (data.type === 'session' && data.session_id) {
              sessionId = data.session_id;
              document.getElementById("sessionId").textContent = sessionId;
              console.log("Session ID received:", sessionId);
              // Do not show session handshake as a chat message
              return;
            }
            
            if (data.type === "text" && data.content) {
              console.log("Adding text message:", data.content);
              addMessage(data.content, "bot");
              // Reset voice processing state
              isProcessingVoice = false;
            } else if (data.content) {
              console.log("Adding content message:", data.content);
              addMessage(data.content, "bot");
              // Reset voice processing state
              isProcessingVoice = false;
            } else if (data.type === "text") {
              console.log("Adding text type message:", data);
              addMessage(String(data), "bot");
              // Reset voice processing state
              isProcessingVoice = false;
            } else {
              console.log("Adding fallback message:", data);
              addMessage(JSON.stringify(data), "bot");
              // Reset voice processing state
              isProcessingVoice = false;
            }
            
            if (data.audio) {
              console.log("Playing audio response");
              playAudio(data.audio);
            }
            if (data.tts_error) {
              console.error("TTS Error:", data.tts_error);
            }
          } catch (e) {
            console.error("Error parsing message:", e);
            // Fallback for plain text messages
            addMessage(event.data, "bot");
          }
        };
        
        ws.onclose = function() {
          isConnected = false;
          updateStatus("Disconnected - Reconnecting...", "disconnected");
          document.getElementById("sendBtn").disabled = true;
          console.log("WebSocket connection closed");
          
          if (reconnectAttempts < maxReconnectAttempts) {
            reconnectAttempts++;
            setTimeout(connect, 3000);
          } else {
            updateStatus("Connection failed after multiple attempts", "disconnected");
          }
        };
        
        ws.onerror = function(error) {
          console.error("WebSocket error:", error);
          updateStatus("Connection error", "disconnected");
        };
        
      } catch (error) {
        console.error("Error creating WebSocket:", error);
        updateStatus("Failed to create connection", "disconnected");
      }
    }
    
    function reconnect() {
      if (ws) {
        ws.close();
      }
      reconnectAttempts = 0;
      connect();
    }
    
    function updateStatus(message, className) {
      const status = document.getElementById("status");
      status.textContent = message;
      status.className = "status " + className;
    }
    
    function addMessage(text, sender, save=true) {
      const chat = document.getElementById("chat");
      const messageDiv = document.createElement("div");
      messageDiv.className = `message ${sender}-message`;
      if (typeof text !== 'string') {
        text = String(text);
      }
      if (text.includes("Error:") || text.toLowerCase().includes("error")) {
        messageDiv.className = "message error-message";
      }
      messageDiv.textContent = text;
      chat.appendChild(messageDiv);
      chat.scrollTop = chat.scrollHeight;
      if (save) {
        const role = messageDiv.classList.contains('user-message') ? 'user' : (messageDiv.classList.contains('error-message') ? 'error' : 'bot');
        persistedMessages.push({ role, text });
        saveChatHistory();
      }
    }
    
    function sendMessage() {
      if (!isConnected) {
        alert("Not connected to server. Please wait for connection or click Reconnect.");
        return;
      }
      
      const msgInput = document.getElementById("msg");
      const message = msgInput.value.trim();
      
      if (message) {
        try {
          ws.send(message);
          addMessage(message, "user");
          msgInput.value = "";
          
          const typingDiv = document.createElement("div");
          typingDiv.className = "message bot-message typing";
          typingDiv.textContent = "AI is thinking...";
          typingDiv.id = "typing";
          document.getElementById("chat").appendChild(typingDiv);
          document.getElementById("chat").scrollTop = document.getElementById("chat").scrollHeight;
          
        } catch (error) {
          console.error("Error sending message:", error);
          addMessage("Error sending message. Please try reconnecting.", "error");
        }
      }
    }
    
    function handleKeyPress(event) {
      if (event.key === "Enter") {
        sendMessage();
      }
    }
    
    function removeTypingIndicator() {
      const typing = document.getElementById("typing");
      if (typing) {
        typing.remove();
      }
    }
    
    function clearChat() {
      if (confirm("Are you sure you want to clear the chat history?")) {
        const chat = document.getElementById("chat");
        chat.innerHTML = '<div class="message bot-message">Hello! I\'m your AI assistant with voice capabilities. You can type your message or click the microphone to speak!</div>';
        localStorage.removeItem('chatHistory');
        saveChatHistory();
      }
    }
    
    function exportChat() {
      const chat = document.getElementById("chat");
      const messages = chat.querySelectorAll('.message');
      let exportText = "AI Voicebot Chat Export\n";
      exportText += "=".repeat(30) + "\n\n";
      
      messages.forEach(msg => {
        const isUser = msg.classList.contains('user-message');
        const sender = isUser ? "You" : "AI";
        exportText += `${sender}: ${msg.textContent}\n\n`;
      });
      
      const blob = new Blob([exportText], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `chat-export-${new Date().toISOString().split('T')[0]}.txt`;
      a.click();
      URL.revokeObjectURL(url);
    }
    
    function downloadAudioLogs() {
      if (clientAudioLogs.length === 0) {
        alert("No audio logs to download");
        return;
      }
      
      let exportText = "Client Audio Logs\n";
      exportText += "=".repeat(30) + "\n\n";
      
      clientAudioLogs.forEach((log, index) => {
        exportText += `Audio ${index + 1}:\n`;
        exportText += `Timestamp: ${log.timestamp}\n`;
        exportText += `Type: ${log.type}\n`;
        exportText += `Duration: ${log.duration}ms\n`;
        exportText += `Size: ${log.size} bytes\n\n`;
      });
      
      const blob = new Blob([exportText], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `audio-logs-${new Date().toISOString().split('T')[0]}.txt`;
      a.click();
      URL.revokeObjectURL(url);
    }
    
    // Voice recording functions using Web Speech API
    let recordingStartTime = 0;
    let isProcessingVoice = false;
    let recognition = null;
    let isListening = false;
    
    // Initialize Web Speech API
    function initializeSpeechRecognition() {
      try {
        // Check if Web Speech API is supported
        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
          console.error('Web Speech API not supported');
          alert('Web Speech API not supported in this browser. Please use Chrome or Edge.');
          return false;
        }
        
        // Create speech recognition instance
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        recognition = new SpeechRecognition();
        
        // Configure recognition settings
        recognition.continuous = false;
        recognition.interimResults = false;
        recognition.lang = 'en-US';
        recognition.maxAlternatives = 1;
        
        // Set up event handlers
        recognition.onstart = function() {
          console.log('Speech recognition started');
          isListening = true;
          updateVoiceUI();
          document.getElementById("voiceStatus").textContent = "Listening...";
        };
        
        recognition.onresult = function(event) {
          const transcript = event.results[0][0].transcript;
          console.log('Speech recognized:', transcript);
          
          // Stop listening
          recognition.stop();
          isListening = false;
          updateVoiceUI();
          
          // Send the transcribed text directly
          sendVoiceMessage(transcript);
        };
        
        recognition.onerror = function(event) {
          console.error('Speech recognition error:', event.error);
          isListening = false;
          updateVoiceUI();
          document.getElementById("voiceStatus").textContent = `Error: ${event.error}`;
          
          if (event.error === 'no-speech') {
            alert('No speech detected. Please try again.');
          } else if (event.error === 'audio-capture') {
            alert('Microphone access denied. Please check permissions.');
          } else {
            alert(`Speech recognition error: ${event.error}`);
          }
        };
        
        recognition.onend = function() {
          console.log('Speech recognition ended');
          isListening = false;
          updateVoiceUI();
          document.getElementById("voiceStatus").textContent = "";
        };
        
        console.log('Web Speech API initialized successfully');
        return true;
        
      } catch (error) {
        console.error('Error initializing Web Speech API:', error);
        alert('Failed to initialize speech recognition. Please try refreshing the page.');
        return false;
      }
    }
    
    // Prevent page unload during voice processing
    window.addEventListener('beforeunload', function(e) {
      if (isProcessingVoice) {
        e.preventDefault();
        e.returnValue = 'Voice message is being processed. Are you sure you want to leave?';
        return e.returnValue;
      }
    });
    
    // Prevent form submission and page reloads
    document.addEventListener('submit', function(e) {
      e.preventDefault();
      console.log('Form submission prevented');
    });
    
    // Prevent any default button actions that might cause page reload
    document.addEventListener('click', function(e) {
      if (e.target.tagName === 'BUTTON' && e.target.type === 'submit') {
        e.preventDefault();
        console.log('Button submission prevented');
      }
    });
    
    async function startRecording() {
      if (!recognition) {
        if (!initializeSpeechRecognition()) {
          return;
        }
      }
      
      try {
        if (isListening) {
          recognition.stop();
          return;
        }
        
        recordingStartTime = Date.now();
        recognition.start();
        
      } catch (error) {
        console.error("Error starting speech recognition:", error);
        alert("Error starting speech recognition. Please try again.");
      }
    }
    
    function stopRecording() {
      if (recognition && isListening) {
        recognition.stop();
      }
    }
    
    function updateVoiceUI() {
      const recordBtn = document.getElementById("recordBtn");
      const stopBtn = document.getElementById("stopBtn");
      
      if (isListening) {
        recordBtn.style.display = "none";
        stopBtn.style.display = "flex";
        stopBtn.classList.add("recording");
      } else {
        recordBtn.style.display = "flex";
        stopBtn.style.display = "none";
        stopBtn.classList.remove("recording");
      }
    }
    
    function sendVoiceMessage(transcript) {
      if (!isConnected) {
        alert("Not connected to server. Please wait for connection or click Reconnect.");
        return;
      }
      
      try {
        // Set processing state
        isProcessingVoice = true;
        
        // Add user message to chat
        addMessage(transcript, "user");
        
        // Check WebSocket state before sending
        if (ws && ws.readyState === WebSocket.OPEN) {
          // Send as text message instead of audio
          ws.send(JSON.stringify({
            type: "text",
            content: transcript
          }));
          
          document.getElementById("voiceStatus").textContent = "Voice message sent, waiting for response...";
          
          const typingDiv = document.createElement("div");
          typingDiv.className = "message bot-message typing";
          typingDiv.textContent = "Processing your voice message...";
          typingDiv.id = "typing";
          document.getElementById("chat").appendChild(typingDiv);
          document.getElementById("chat").scrollTop = document.getElementById("chat").scrollHeight;
          
          console.log("Voice message sent successfully:", transcript);
        } else {
          console.error("WebSocket not ready, current state:", ws ? ws.readyState : "null");
          alert("Connection not ready. Please wait for connection or click Reconnect.");
          document.getElementById("voiceStatus").textContent = "";
          isProcessingVoice = false;
        }
        
      } catch (error) {
        console.error("Error sending voice message:", error);
        addMessage("Error sending voice message. Please try reconnecting.", "error");
        document.getElementById("voiceStatus").textContent = "";
        isProcessingVoice = false;
      }
    }
    
    function playAudio(audioBase64) {
      try {
        const audioData = atob(audioBase64);
        const audioArray = new Uint8Array(audioData.length);
        for (let i = 0; i < audioData.length; i++) {
          audioArray[i] = audioData.charCodeAt(i);
        }
        
        const audioBlob = new Blob([audioArray], { type: 'audio/wav' });
        const audioUrl = URL.createObjectURL(audioBlob);
        
        const audioLog = {
          timestamp: new Date().toISOString(),
          type: 'bot_audio_playback',
          duration: 0,
          size: audioBlob.size
        };
        clientAudioLogs.push(audioLog);
        
        const audio = new Audio(audioUrl);
        audio.play().catch(error => {
          console.error("Error playing audio:", error);
        });
        audio.onended = function() {
          audioLog.duration = audio.duration * 1000;
          URL.revokeObjectURL(audioUrl);
        };
        
      } catch (error) {
        console.error("Error playing audio:", error);
      }
    }
    
    loadChatHistory();
    connect();
  </script>
</body>
</html>
